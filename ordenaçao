#ORDENAÇÃO POR SELEÇÃO
def ordenacao_selecao(lista):
    n = len(lista)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if lista[j] < lista[min_idx]:
                min_idx = j
        lista[i], lista[min_idx] = lista[min_idx], lista[i]
    return lista


# QUICKSORT (RECURSIVO)
def quicksort(lista):
    if len(lista) <= 1:
        return lista
    pivo = lista[len(lista)//2]
    menores = [x for x in lista if x < pivo]
    iguais = [x for x in lista if x == pivo]
    maiores = [x for x in lista if x > pivo]
    return quicksort(menores) + iguais + quicksort(maiores)


# TESTE DAS ORDENAÇÕES 
lista = [random.randint(0, 10000) for _ in range(1000)]

inicio = time.time()
ordenacao_selecao(lista.copy())
tempo_selecao = time.time() - inicio

inicio = time.time()
quicksort(lista.copy())
tempo_quicksort = time.time() - inicio

inicio = time.time()
sorted(lista.copy())
tempo_sorted = time.time() - inicio

print("\n=== ORDENAÇÃO ===")
print(f"Seleção → {tempo_selecao:.6f}s")
print(f"Quicksort → {tempo_quicksort:.6f}s")
print(f"sorted() → {tempo_sorted:.6f}s")


#RESUMO PEDIDO:
#Ordenação por Seleção → lenta (O(n²)).
#Quicksort e sorted() → muito mais rápidos (O(n log n)).
#Recursivos → demonstram o conceito de chamada de função dentro dela mesma.
